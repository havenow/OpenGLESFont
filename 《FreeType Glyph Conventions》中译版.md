- # I. Basic Typographic Concepts
1. Font files, format and information
2. Character images and mappings
3. Character and font metrics

- # II. Glyph Outlines
1. Pixels, points and device resolutions
2. Vectorial representation
3. Hinting and bitmap rendering

- # III. Glyph Metrics
1. Baseline, pens and layouts
2. Typographic metrics and bounding boxes
3. Bearings and advances
4. The effects of grid-fitting
5. Text widths and bounding box

- # IV. Kerning
1. Kerning pairs
2. Applying kerning

- # V. Text Processing
1. Writing simple text strings
2. Sub-pixel positioning
3. Simple kerning
4. Right-to-left layouts
5. Vertical layouts

- # VI. FreeType Outlines
1. FreeType outline description and structure
2. Bounding and control box computations
3. Coordinates, scaling, and grid-fitting

- # VII. FreeType Bitmaps
1. Vectorial versus pixel coordinates
2. The FT_Bitmap descriptor
3. Converting outlines into bitmaps and pixmaps

- # 一、基本印刷概念 
1. 字体文件、格式和信息    
字体是一组可以被显示和打印的多样的字符映像，在单个字体中共享一些共有的特性，包括外表、风格、衬线等。按印刷领域的说法，它必须区别一个字体 家族和多种字体外观，后者通常是从同样的模板而来，但是风格不同。例如，Palatino Regular 和 Palatino Italic是两种不同的外观，但是属于同样的家族Palatino。 

单个字体术语根据上下文既可以指家族也可指外观。例如，大多文字处理器的用户用字体指不同的字体家族，然而，大多这些家族根据它们的格式会通过多 个数据文件实现。对于 TrueType来讲，通常是每个外观一个文件（arial.ttf对应Arial Regular外观，ariali.ttf对应Arial Italic外观）这个文件也叫字体，但是实际上只是一个字体外观。 

数字字体是一个可以包含一个和多个字体外观的数据文件，它们每个都包含字符映像、字符度量，以及其他各种有关文本布局和特定字符编码的重要信息。 对有些难用的格式，像Adobe的Type1，一个字体外观由几个文件描述（一个包含字符映象，一个包含字符度量等）。在这里我们忽略这种情况，只考虑一 个外观一个文件的情况，不过在FT2.0中，能够处理多文件字体。 

为了方便说明，一个包含多个外观的字体文件我们叫做字体集合，这种情况不多见，但是多数亚洲字体都是如此，它们会包含两种或多种表现形式的映像，例如横向和纵向布局。 

2. 字符映象和图        
字符映象叫做字形，根据书写、用法和上下文，单个字符能够有多个不同的映象，即多个字形。多个字符也可以有一个字形（例如Roman？？）。字符 和字形之间的关系可能是非常复杂，本文不多述。而且，多数字体格式都使用不太难用的方案存储和访问字形。为了清晰的原因，当说明FT时，保持下面的观念 

* 一个字体文件包含一组字形，每个字形可以存成位图、向量表示或其他结构（更可缩放的格式使用一种数学表示和控制数据/程序的结合方式）。这些字形可以以任意顺序存在字体文件中，通常通过一个简单的字形索引访问。 

* 字体文件包含一个或多个表，叫做字符图，用来为某种字符编码将字符码转换成字形索引，例如ASCII、Unicode、Big5等等。单个字体文件可能包 含多个字符图，例如大多TrueType字体文件都会包含一个Apple特定的字符图和Unicode字符图，使它在Mac和Windows平台都可以使 用。 

3. 字符和字体度量      
每个字符映象都关联多种度量，被用来在渲染文本时，描述如何放置和管理它们。在后面会有详述，它们和字形位置、光标步进和文本布局有关。它们在渲染一个文本串时计算文本流时非常重要。 

每个可缩放的字体格式也包含一些全局的度量，用概念单位表示，描述同一种外观的所有字形的一些特性，例如最大字形外框，字体的上行字符、下行字符和文本高度等。 

虽然这些度量也会存在于一些不可缩放格式，但它们只应用于一组指定字符维度和分辨率，并且通常用象素表示。 

- # 二、字形轮廓 
1. 象素、点和设备解析度      
当处理计算机图形程序时，指定象素的物理尺寸不是正方的。通常，输出设备是屏幕或打印机，在水平和垂直方向都有多种分辨率，当渲染文本是要注意这些情况。 

定义设备的分辨率通常使用用dpi（每英寸点(dot)数）表示的两个数，例如，一个打印机的分辨率为300x600dpi表示在水平方向，每英 寸有300 个象素，在垂直方向有600个象素。一个典型的计算机显示器根据它的大小，分辨率不同（15’’和17’’显示器对640x480象素大小不同），当然图 形模式分辨率也不一样。 

所以，文本的大小通常用点（point）表示，而不是用设备特定的象素。点是一种简单的物理单位，在数字印刷中，一点等于1/72英寸。例如，大多罗马书籍使用10到14点大小印刷文字内容。 

可以用点数大小来计算象素数，公式如下： 

象素数 = 点数*分辨率/72 

分辨率用dpi表示，因为水平和垂直分辨率可以不同，单个点数通常定义不同象素文本宽度和高度。 

2. 向量表示     
字体轮廓的源格式是一组封闭的路径，叫做轮廓线。每个轮廓线划定字形的外部或内部区域，它们可以是线段或是Bezier曲线。 

曲线通过控制点定义，根据字体格式，可以是二次(conic Beziers)或三次(cubic Beziers)多项式。在文献中，conic Bezier通常称为quadratic Beziers。因此，轮廓中每个点都有一个标志表示它的类型是一般还是控制点，缩放这些点将缩放整个轮廓。 

每个字形最初的轮廓点放置在一个不可分割单元的网格中，点通常在字体文件中以16位整型网格坐标存储，网格的原点在(0,0)，它的范围是-16384到-16383（虽然有的格式如Type1使用浮点型，但为简便起见，我们约定用整型分析）。 

网格的方向和传统数学二维平面一致，x轴从左到右，y轴从下到上。 

在创建字形轮廓时，一个字体设计者使用一个假想的正方形，叫做EM正方形。他可以想象成一个画字符的平面。正方形的大小，即它边长的网格单元是很重要的，原因是 

* 它是用来将轮廓缩放到指定文本尺寸的参考，例如在300x300dpi中的12pt大小对应12*300/72=50象素。从网格单元缩放到象素可以使用下面的公式 

象素数 ＝ 点数 × 分辨率/72 
象素坐标＝ 网格坐标*象素数/EM大小 

* EM尺寸越大，可以达到更大的分辨率，例如一个极端的例子，一个4单元的EM，只有25个点位置，显然不够，通常TrueType字体之用2048单元的EM；Type1 PostScript字体有一个固定1000网格单元的EM，但是点坐标可以用浮点值表示。 

注意，字形可以自由超出EM正方形。网格单元通常交错字体单元或EM单元。上边的象素数并不是指实际字符的大小，而是EM正方形显示的大小，所以不同字体，虽然同样大小，但是它们的高度可能不同。 

3. Hinting和位图渲染      
存储在一个字体文件中的轮廓叫“主”轮廓，它的点坐标用字体单元表示，在它被转换成一个位图时，它必须缩放至指定大小。这通过一个简单的转换完成，但是总会产生一些不想要的副作用，例如像字母E和H，它们主干的宽度和高度会不相同。 

所以，优秀的字形渲染过程在缩放“点”是，需要通过一个网格对齐(grid-fitting)的操作（通常叫hinting），将它们对齐到目标 设备的象素网格。这主要目的之一是为了确保整个字体中，重要的宽度和高度能够一致。例如对于字符I和T来说，它们那个垂直笔划要保持同样象素宽度。另外， 它的目的还有管理如stem和overshoot的特性，这在小象素字体会引起一些问题。 

有若干种方式来处理网格对齐，多数可缩放格式中，每种字形轮廓都有一些控制数据和程序。 

* 显式网格对齐 

TrueType格式定义了一个基于栈的虚拟机（VM），可以借助多于200中操作码（大多是几何操作）来编写程序，每个字形都由一个轮廓和一个控制程序组成，后者可以处理实际的网格对齐，他由字体设计者定义。 

* 隐式网格对齐（也叫hinting） 

Type1格式有一个更简单的方式，每个字形由一个轮廓以及若干叫hints的片断组成，后者用来描述字形的某些重要特性，例如主干的存在、某些宽度匀称性等诸如此类。没有多少种hint，要看渲染器如何解释hint来产生一个对齐的轮廓。 

* 自动网格对齐 

有些格式很简单，没有包括控制信息，将字体度量如步进、宽度和高度分开。要靠渲染器来猜测轮廓的一些特性来实现得体的网格对齐。 

下面总结了每种方案的优点和缺点 

方案	优点	缺点 

显式	质量：对小字体有很好的结果，这对屏幕显示非常重要。	速度：如果程序很复杂，解释字节码很慢 
一致性：所有渲染器产生同样的字形位图。	大小：字形程序会很长。 
技术难度：编写优秀的hinting程序非常难，没有好的工具支持。 

隐式	大小：Hint通常比显式字形程序小的多	质量：小字体不好，最后结合反走样 
速度：网格对齐会非常快	不一致：不同渲染器结果不同，甚至同一引擎不同版本也不同。 

自动	大小：不需要控制信息，导致更小的字体文件	质量：小字体不好，最后结合反走样 
速度：依赖对齐算法，通常比显式对齐快。	速度：依赖算法 
不一致：不同渲染器结果不同，甚至同一引擎不同版本也不同。

- # 三、字形度量 
1. 基线(baseline)、笔(pen)和布局(layout)    
基线是一个假想的线，用来在渲染文本时知道字形，它可以是水平（如Roman）和是垂直的（如中文）。而且，为了渲染文本，在基线上有一个虚拟的点，叫做笔位置（pen position）或原点（origin），他用来定位字形。 

每种布局使用不同的规约来放置字形： 

* 对水平布局，字形简单地搁在基线上，通过增加笔位置来渲染文本，既可以向右也可以向左增加。 

两个相邻笔位置之间的距离是根据字形不同的，叫做步进宽度（advance width）。注意这个值总是正数，即使是从右往左的方向排列字符，如Arabic。这和文本渲染的方式有些不同。 

笔位置总是放置在基线上。 


* 对垂直布局，字形在基线上居中放置： 


2. 印刷度量和边界框     
在指定字体中，定义了多种外观度量。 

* 上行高度（ascent）。从基线到放置轮廓点最高/上的网格坐标，因为Y轴方向是向上的，所以它是一个正值。 

* 下行高度（descent）。从基线到放置轮廓点最低/下的网格坐标，因为Y轴方向是向上的，所以它是一个负值。 

* 行距（linegap）。两行文本间必须的距离，基线到基线的距离应该计算成 

上行高度 － 下行高度 ＋ 行距 

* 边界框（bounding box，bbox）。这是一个假想的框子，他尽可能紧密的装入字形。通过四个值来表示，叫做xMin、yMin、xMax、yMax，对任何轮廓都可以计 算，它们可以是字体单元（测量原始轮廓）或者整型象素单元（测量已缩放的轮廓）。注意，如果不是为了网格对齐，你无需知道这个框子的这个值，只需知道它的 大小即可。但为了正确渲染一个对齐的字形，需要保存每个字形在基线上转换、放置的重要对齐。 

* 内部leading。这个概念从传统印刷业而来，他表示字形出了EM正方形空间数量，通常计算如下 

internal leading = ascent – descent – EM_size 

* 外部leading。行距的别名。 

3. 跨距（bearing）和步进         
每个字形都有叫跨距和步进的距离，它们的定义是常量，但是它们的值依赖布局，同样的字形可以用来渲染横向或纵向文字。 

* 左跨距或bearingX。从当前笔位置到字形左bbox边界的水平距离，对水平布局是正数，对垂直布局大多是负值。 

* 上跨距或bearingY。从基线到bbox上边界的垂直距离，对水平布局是正值，对垂直布局是负值。 

* 步进宽度或advanceX。当处理文本渲染一个字形后，笔位置必须增加（从左向右）或减少（从右向左）的水平距离。对水平布局总是正值，垂直布局为null。 

* 步进高度或advanceY。当每个字形渲染后，笔位置必须减少的垂直距离。对水平布局为null，对垂直布局总是正值。 

* 字形宽度。字形的水平长度。对未缩放的字体坐标，它是bbox.xMax-bbox.xMin，对已缩放字形，它的计算要看特定情况，视乎不同的网格对齐而定。 

* 字形高度。字形的垂直长度。对未缩放的字体坐标，它是bbox.yMax-bbox.yMin，对已缩放字形，它的计算要看特定情况，视乎不同的网格对齐而定。 

* 右跨距。只用于水平布局，描述从bbox右边到步进宽度的距离，通常是一个非负值。 

advance_width – left_side_bearing – (xMax-xMin) 

下图是水平布局所有的度量 


下图是垂直布局的度量 


4. 网格对齐的效果     
因为hinting将字形的控制点对齐到象素网格，这个过程将稍稍修改字符映象的尺寸，和简单的缩放有所区别。例如，小写字母m的映象在主网格中 有时是一个正方形，但是为了使它在小象素大小情况下可以辨别，hinting试图扩大它已缩放轮廓，以让它三条腿区分开来，这将导致一个更大的字符位图。 

字形度量也会受网格对齐过程的影响： 

* 映象的宽度和高度改变了，即使只是一个象素，对于小象素大小字形区别都很大； 

* 映象的边界框改变了，也改变了跨距； 

* 步进必须更改，例如如果被hint的位图比缩放的位图大时，必须增加步进宽度，来反映扩大的字形宽度。 

这有一些含义如下， 

* 因为hinting，简单缩放字体上行或下行高度可能不会有正确的结果，一个可能的方法时保持被缩放上行高度的顶和被缩放下行高度的底。 

* 没有容易的方法去hint一个范围内字形并步进它们宽度，因为hinting对每个轮廓工作都不一样。唯一的方法时单独hint每个字形，并记录返回值。有些格式，如TrueType，包含一些表对一些通用字符预先计算出它们的象素大小。 

* hinting依赖最终字符宽度和高度的象素值，意味着它非常依赖分辨率，这个特性使得正确的所见即所得布局非常难以实现。 

在FT 中，对字形轮廓处理2D变换很简单，但是对一个已hint的轮廓，需要注意专有地使用整型象素距离（意味着FT_Outline_Translate() 函数的参数应该都乘以64，因为点坐标都是26.6固定浮点格式），否则，变换将破坏hinter的工作，导致非常难看的位图。 

5. 文本宽度和边界框     
如上所示，指定字形的原点对应基线上笔的位置，没有必要定位字形边界框的某个角，这不像多数典型的位图字体格式。有些情况，原点可以在边界框的外边，有时，也可以在里边，这要看给定的字形外形了。 

同样，字形的步进宽度是在布局时应用于笔位置的增量，而不是字形的宽度，那是字形边界的宽度。对文本串，具有相同的规约，这意味着： 

* 指定文本串的边界框没有必要包含文本光标，也不需要后边的字形放置在它的角上。 

* 字符串的步进宽度和它的边界框大小无关，特别时它在开始和最后包含空格或tab。 

* 最后，附加的处理如间距调整能够创建文本串，它的大小不直接依赖单独字形度量并列排列。例如，VA的步进宽度不是V和A各自的步进之和。 

- # 四、字距调整 
字距调整这个术语指用来在一个文本串中调整重合字形的相对位置的特定信息。 

1. 字距调整对     
字距调整包括根据相邻字形的轮廓修改它们之间的距离。例如T和y可以贴得更近一点，因为y的上缘正好在T的右上角一横的下边。 

当仅仅根据字形的标准宽度来布局文本，一些连续的字符看上去有点太挤和太松，例如下图中A和V的就显得距离太远。 


比较一下下图，同样的单词，A和V的距离拉近些 


可以看到，这个调整可以导致很大的区别。有的字体外观包含一个表，它包含文本布局所需的指定字形对的字距距离。 

* 这个对是顺序的，AV对的距离和VA对不一定一致； 

* 依据布局或书写，字距可以表示水平或垂直方向。 

* 字距表示成网格单元，它们通常是X轴方向的，意味着负值表示两个字形需要在水平方向放的更近一点。 

2. 应用字距调整     
在渲染文本时应用字据调整是一个比较简单的过程，只需要在写下一个字形时，将缩放的字距加到笔位置即可。然而，正确的渲染器要考虑的更细一点。 

“滑动点”问题是一个很好的例子：很多字体外观包括一个大写字符（如T、F）和一个点.之间的字距调整，以将点正好放置在前者的主腿的右侧。 


根据字符的外形，有时候需要在点和随后的字符间作附加的调整，当应用“标准”的字距调整，上面的句子如下 


这显然太紧凑了。一个方案是，只在需要时滑动点，当然这需要对文本的意思有了解。如果当我们在渲染特定段落的最后一个点时，上面的调整就不适合了。这只是一个例子，还有很多其他例子显示一个真正的印刷工人需要恰当地布局文本。 

有一个很简单地算法，可以避免滑动点问题。 

1. 在基线上放置第一个字形； 
2. 将笔位置保存到pen1； 
3. 根据第一个和第二个字形的字距距离调整笔位置； 
4. 放置第二个字形，并计算下个笔位置，放到pen2； 
5. 如果pen1大于pen2，使用pen1作为下个笔位置，否则使用pen2。 
